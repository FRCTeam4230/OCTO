// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4230.OCTO.commands;

import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc4230.OCTO.Drive;
import org.usfirst.frc4230.OCTO.Robot;
import org.usfirst.frc4230.OCTO.RobotMap;

/**
 *
 */
public class AutonomousCommand extends Command {

	double lastTime = 0;
	double currentTime;
	double speedDistance = 0;
	double gyroSpeed;
	double prevGyroSpeed = 0;
	// public static double startAngle;
	double driveTime;
	double driveSpeed = 250.0;
	double driveRotation = 250.0;
	private double camX = 0;
	double turnDiff;
	final double TURNSENS = 5;
	double targetGyro = 30;
	double rotation;
	boolean cancel = false;
	int autoCount = 0;
	double startTime = 0;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public AutonomousCommand() {

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
		requires(Robot.driveTrain);

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
		requires(Robot.shooter);
		requires(Robot.gearFlappers);
	}

	// always set speed before time.

	// Called just before this Command runs the first time
	protected void initialize() {
		// startAngle = RobotMap.adiGyro.getAngleX();
		RobotMap.adiGyro.calibrate();
		RobotMap.adiGyro.reset();
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
		if (autoCount == 0) {
			Drive.octoDrive(-1.0, 0.5, 0.0, 250.0, 150.0, 0.0);
			Timer.delay(1.35);
			Drive.octoDrive(0.0, 0.0, 0.0, 250.0, 150.0, 0.0);
			autoCount = 1;
		}

		if (RobotMap.pref.getDouble("Auto", 0) == 1) {
			targetGyro = 150;

			// This loop is getting stuck. I think the rotation is getting small
			// enough where
			// it doesn't move. If the gyro drift adjusts it will eventually
			// take off and then look out.
			if (autoCount == 1) {
				if ((RobotMap.adiGyro.getAngleX() < 120.0 || RobotMap.adiGyro.getAngleX() > 130.0)) {
					turnDiff = (targetGyro - RobotMap.adiGyro.getAngleX());
					rotation = 0.5;
					/*
					 * if (Math.abs(turnDiff) > TURNSENS) { rotation = (turnDiff
					 * / 120.0); } else { rotation = 0.1; }
					 */
					Drive.octoDrive(0.0, 0.0, rotation, 175.0, 75.0, RobotMap.adiGyro.getAngleX());
					SmartDashboard.putNumber("Auto Gyro", RobotMap.adiGyro.getAngleX());
				} else {
					autoCount = 2;
					Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
					Timer.delay(0.2);
					startTime = Timer.getFPGATimestamp();
				}
			}
			// SmartDashboard.putNumber("Stupid", rotation);

			

			if (autoCount == 2) {
				if ((Timer.getFPGATimestamp() - startTime < 2.0) && !cancel) {
					turnDiff = (targetGyro - RobotMap.adiGyro.getAngleX());
					rotation = (turnDiff / 90);
					Drive.octoDrive(-0.3, 1.0, rotation, 150.0, 175.0, 0.0);
				} else {
					Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
					autoCount = 3;
				}
			}

			if (autoCount == 3) {
				RobotMap.gearFlappersFrontFlap.set(0);
				Timer.delay(0.2);
				RobotMap.gearFlappersBackFlap.setPosition(0.25);
				Timer.delay(0.2);
				RobotMap.gearFlappersBackFlap.setPosition(0.95);
				Timer.delay(0.2);
				RobotMap.gearFlappersBackFlap.setPosition(0.25);
				Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
				Timer.delay(0.2);
				Drive.octoDrive(0.0, -1.0, 0.0, 175.0, 125.0, 0.0);
				Timer.delay(2.0);
				Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
				RobotMap.gearFlappersBackFlap.setPosition(0.95);
				RobotMap.gearFlappersFrontFlap.set(30);
				autoCount = 4;
			}

		} else if (RobotMap.pref.getDouble("Auto", 0) == 2){
			targetGyro = 30;
			if (autoCount == 1) {
				if ((RobotMap.adiGyro.getAngleX() < 20.0 || RobotMap.adiGyro.getAngleX() > 40.0)) {
					turnDiff = (targetGyro - RobotMap.adiGyro.getAngleX());
					rotation = 0.5;
					/*
					 * if (Math.abs(turnDiff) > TURNSENS) { rotation = (turnDiff
					 * / 120.0); } else { rotation = 0.1; }
					 */
					Drive.octoDrive(0.0, 0.0, rotation, 175.0, 75.0, RobotMap.adiGyro.getAngleX());
					SmartDashboard.putNumber("Auto Gyro", RobotMap.adiGyro.getAngleX());
				} else {
					autoCount = 2;
					Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
					Timer.delay(0.5);
					startTime = Timer.getFPGATimestamp();
				}
			}
			// SmartDashboard.putNumber("Stupid", rotation);

			

			if (autoCount == 2) {
				if ((Timer.getFPGATimestamp() - startTime < 2.0) && !cancel) {
					turnDiff = (targetGyro - RobotMap.adiGyro.getAngleX());
					rotation = (turnDiff / 90);
					Drive.octoDrive(-0.3, 1.0, rotation, 125.0, 175.0, 0.0);
				} else {
					Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
					autoCount = 9;
				}
			}

			if (autoCount == 3) {
				RobotMap.gearFlappersFrontFlap.set(0);
				Timer.delay(0.25);
				RobotMap.gearFlappersBackFlap.setPosition(0.25);
				Timer.delay(0.5);
				RobotMap.gearFlappersBackFlap.setPosition(0.95);
				Timer.delay(0.5);
				RobotMap.gearFlappersBackFlap.setPosition(0.25);
				Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
				Timer.delay(0.5);
				Drive.octoDrive(0.0, -1.0, 0.0, 125.0, 125.0, 0.0);
				Timer.delay(2.0);
				Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
				RobotMap.gearFlappersBackFlap.setPosition(0.95);
				RobotMap.gearFlappersFrontFlap.set(30);
				autoCount = 4;
			}
		}
		
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return false;
	}

	// Called once after isFinished returns true
	protected void end() {
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
		cancel = true;
	}

	/*
	 * void autoDrive(double distance, double moveAngle, double rotation) {
	 * currentTime = System.currentTimeMillis(); double myTime = currentTime -
	 * lastTime; gyroSpeed = Math.sqrt((RobotMap.adiGyro.getAccelX() *
	 * RobotMap.adiGyro.getAccelX()) + (RobotMap.adiGyro.getAccelX() *
	 * RobotMap.adiGyro.getAccelX())); speedDistance = myTime * 0.5 * (gyroSpeed
	 * + prevGyroSpeed); while (speedDistance < distance) { double gyroAngle =
	 * RobotMap.adiGyro.getAngleX() - startAngle; double driveAngle = gyroAngle
	 * - moveAngle;
	 * 
	 * for (int i = 0; i < RobotMap.MAXWheels; i++) {
	 * RobotMap.wheels[i].driveWheel(driveAngle, 0.0, 0.0, 0.0); }
	 * 
	 * }
	 * 
	 * }
	 */
}
