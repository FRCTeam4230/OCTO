// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4230.OCTO.commands;

import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc4230.OCTO.Drive;
import org.usfirst.frc4230.OCTO.Robot;
import org.usfirst.frc4230.OCTO.RobotMap;

/**
 *
 */
public class AutonomousCommand extends Command {

	double lastTime = 0;
	double currentTime;
	double speedDistance = 0;
	double gyroSpeed;
	double prevGyroSpeed = 0;
	// public static double startAngle;
	double driveTime;
	double driveSpeed = 250.0;
	double driveRotation = 250.0;
	private double camX = 0;
	double turnDiff;
	final double TURNSENS = 5;
	double targetGyro = 30;
	double rotation;
	boolean cancel = false;
	int autoCount = 0;
	double startTime = 0;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public AutonomousCommand() {

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
		requires(Robot.driveTrain);

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
		requires(Robot.shooter);
		requires(Robot.gearFlappers);
	}

	// always set speed before time.

	// Called just before this Command runs the first time
	protected void initialize() {
		// startAngle = RobotMap.adiGyro.getAngleX();
		RobotMap.adiGyro.calibrate();
		RobotMap.adiGyro.reset();
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
		Drive.octoDrive(-1.0, 0.5, 0.0, 175.0, 150.0, 0.0);
		Timer.delay(0.9);

		if (RobotMap.pref.getBoolean("Left?", true)) {
			targetGyro = 150;

			// This loop is getting stuck. I think the rotation is getting small
			// enough where
			// it doesn't move. If the gyro drift adjusts it will eventually
			// take off and then look out.
			if (autoCount == 0) {
				if ((RobotMap.adiGyro.getAngleX() < 120.0 || RobotMap.adiGyro.getAngleX() > 130.0)) {
					turnDiff = (targetGyro - RobotMap.adiGyro.getAngleX());
					rotation = 0.5;
					/*
					 * if (Math.abs(turnDiff) > TURNSENS) { rotation = (turnDiff
					 * / 120.0); } else { rotation = 0.1; }
					 */
					Drive.octoDrive(0.0, 0.0, rotation, 125.0, 75.0, RobotMap.adiGyro.getAngleX());
					SmartDashboard.putNumber("Auto Gyro", RobotMap.adiGyro.getAngleX());
				} else {
					autoCount = 1;
					Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
					Timer.delay(0.5);
				}
			}
			// SmartDashboard.putNumber("Stupid", rotation);

			double[] targetNum = new double[10];
			camX = 0.0;
			SmartDashboard.putNumber("Camera Auto", camX);
			if (autoCount == 1) {
				if (camX < 270 || camX > 290) {
					targetNum = Robot.table.getNumberArray("LINE_PATTERN", targetNum);
					if (targetNum == null || targetNum.length < 2) {
						camX = 0.0;
					} else {
						SmartDashboard.putNumber("num", targetNum.length);
						camX = targetNum[1];
					}
					SmartDashboard.putNumber("Camera Auto", camX);

					double camDiff = 320 - camX;
					double speed = 1.0;
					turnDiff = (targetGyro - RobotMap.adiGyro.getAngleX());
					rotation = (turnDiff / 90) * 90;
					SmartDashboard.putNumber("Auto Rotate", rotation);

					/*
					 * if (Math.abs(turnDiff) > TURNSENS) { rotation = (turnDiff
					 * / 120.0) * 75.0; } else { rotation = 0.0; }
					 */

					for (int i = 0; i < RobotMap.MAXWheels; i++) {
						RobotMap.wheels[i].driveWheel(0.0, 0.0, speed * 25, rotation);
					}
				} else {
					Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
					Timer.delay(0.5);
					autoCount = 2;
					startTime = Timer.getFPGATimestamp();
				}
			}

			if (autoCount == 2) {
				if ((Timer.getFPGATimestamp() - startTime < 2.0) && !cancel) {
					turnDiff = (targetGyro - RobotMap.adiGyro.getAngleX());
					rotation = (turnDiff / 90);
					Drive.octoDrive(-0.5, 1.0, rotation, 125.0, 175.0, 0.0);
				} else {
					Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
					autoCount = 3;
				}
			}

			if (autoCount == 3) {
				RobotMap.gearFlappersFrontFlap.set(0);
				Timer.delay(0.25);
				RobotMap.gearFlappersBackFlap.setPosition(0.25);
				Timer.delay(0.5);
				RobotMap.gearFlappersBackFlap.setPosition(0.95);
				Timer.delay(0.5);
				RobotMap.gearFlappersBackFlap.setPosition(0.25);
				Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
				Timer.delay(0.5);
				Drive.octoDrive(0.0, -1.0, 0.0, 125.0, 125.0, 0.0);
				Timer.delay(1.0);
				Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
				autoCount = 4;
			}

		} else {
			targetGyro = 30;
			if (autoCount == 0) {
				if ((RobotMap.adiGyro.getAngleX() < 25.0 || RobotMap.adiGyro.getAngleX() > 35.0)) {
					turnDiff = (targetGyro - RobotMap.adiGyro.getAngleX());
					rotation = 0.5;
					/*
					 * if (Math.abs(turnDiff) > TURNSENS) { rotation = (turnDiff
					 * / 120.0); } else { rotation = 0.1; }
					 */
					Drive.octoDrive(0.0, 0.0, rotation, 125.0, 75.0, RobotMap.adiGyro.getAngleX());
					SmartDashboard.putNumber("Auto Gyro", RobotMap.adiGyro.getAngleX());
				} else {
					autoCount = 1;
					Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
					Timer.delay(0.5);
				}
			}
			// SmartDashboard.putNumber("Stupid", rotation);

			double[] targetNum = new double[10];
			camX = 0.0;
			SmartDashboard.putNumber("Camera Auto", camX);
			if (autoCount == 1) {
				if (camX < 270 || camX > 290) {
					targetNum = Robot.table.getNumberArray("LINE_PATTERN", targetNum);
					if (targetNum == null || targetNum.length < 2) {
						camX = 0.0;
					} else {
						SmartDashboard.putNumber("num", targetNum.length);
						camX = targetNum[1];
					}
					SmartDashboard.putNumber("Camera Auto", camX);

					double camDiff = 320 - camX;
					double speed = 1.0;
					turnDiff = (targetGyro - RobotMap.adiGyro.getAngleX());
					rotation = (turnDiff / 90) * 90;
					SmartDashboard.putNumber("Auto Rotate", rotation);

					/*
					 * if (Math.abs(turnDiff) > TURNSENS) { rotation = (turnDiff
					 * / 120.0) * 75.0; } else { rotation = 0.0; }
					 */

					for (int i = 0; i < RobotMap.MAXWheels; i++) {
						RobotMap.wheels[i].driveWheel(0.0, 0.0, -speed * 25, rotation);
					}
				} else {
					Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
					Timer.delay(0.5);
					autoCount = 2;
					startTime = Timer.getFPGATimestamp();
				}
			}

			if (autoCount == 2) {
				if ((Timer.getFPGATimestamp() - startTime < 2.0) && !cancel) {
					turnDiff = (targetGyro - RobotMap.adiGyro.getAngleX());
					rotation = (turnDiff / 90);
					Drive.octoDrive(-0.5, 1.0, rotation, 125.0, 175.0, 0.0);
				} else {
					Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
					autoCount = 3;
				}
			}

			if (autoCount == 3) {
				RobotMap.gearFlappersFrontFlap.set(0);
				Timer.delay(0.25);
				RobotMap.gearFlappersBackFlap.setPosition(0.25);
				Timer.delay(0.5);
				RobotMap.gearFlappersBackFlap.setPosition(0.95);
				Timer.delay(0.5);
				RobotMap.gearFlappersBackFlap.setPosition(0.25);
				Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
				Timer.delay(0.5);
				Drive.octoDrive(0.0, -1.0, 0.0, 125.0, 125.0, 0.0);
				Timer.delay(1.0);
				Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
				autoCount = 4;
			}
		}
		Drive.octoDrive(0.0, 0.0, 0.0, 150.0, 150.0, 0.0);
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return true;
	}

	// Called once after isFinished returns true
	protected void end() {
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
		cancel = true;
	}

	/*
	 * void autoDrive(double distance, double moveAngle, double rotation) {
	 * currentTime = System.currentTimeMillis(); double myTime = currentTime -
	 * lastTime; gyroSpeed = Math.sqrt((RobotMap.adiGyro.getAccelX() *
	 * RobotMap.adiGyro.getAccelX()) + (RobotMap.adiGyro.getAccelX() *
	 * RobotMap.adiGyro.getAccelX())); speedDistance = myTime * 0.5 * (gyroSpeed
	 * + prevGyroSpeed); while (speedDistance < distance) { double gyroAngle =
	 * RobotMap.adiGyro.getAngleX() - startAngle; double driveAngle = gyroAngle
	 * - moveAngle;
	 * 
	 * for (int i = 0; i < RobotMap.MAXWheels; i++) {
	 * RobotMap.wheels[i].driveWheel(driveAngle, 0.0, 0.0, 0.0); }
	 * 
	 * }
	 * 
	 * }
	 */
}
